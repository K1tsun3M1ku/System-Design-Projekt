// WARNING: remove this header when compiling
#include "headers/NBCCommon.h"

/*
 * ¦¦¦¦¦¦¦¦¦¦
 * ¦ STATES ¦
 * ¦¦¦¦¦¦¦¦¦¦
 */
#define STATE_INITIALIZE 0
#define STATE_FOLLOW_LINE 1
#define STATE_TURN_AROUND 2

/*
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦
 * ¦ CONSTANTS ¦
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦
 */
#define SENSOR_LEFT IN_2
#define SENSOR_RIGHT IN_1
#define SENSOR_LINE IN_4
#define SENSOR_ULTRASONIC IN_3

#define MOTOR_LEFT OUT_A
#define MOTOR_RIGHT OUT_C
#define MOTOR_BOTH OUT_AC
#define MOTOR_CURVE_DRAW 20
#define MOTOR_FULL_SPEED 40

#define DISTANCE_CORNER_MIDDLE 15
#define DISTANCE_WALL_BUFFER 5
#define DISTANCE_TIRE_TIRE 10
#define APPROACH_WALL_SPEED_MODIFIER 5
#define APPROACH_WALL_MEASURE_INTERVAL MS_5

/*
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
 * ¦ GLOBAL VARIABLES ¦
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
 */
int state = STATE_INITIALIZE;

/*
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
 * ¦ GLOBAL VARIABLES ¦
 * ¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦¦
 */
int light_threshold = -1; // NOTE: lighter color reflects more light -> Higher measurement
float approx_speed = -1; // unit: cm/ms
int motor_throttle = MOTOR_FULL_SPEED;
float gap_min_diff = -1;
int gap_traversed = 0;

task approachWall() {
  int distance_start = SensorUS(SENSOR_ULTRASONIC);
  int distance_now = INT_MAX;
  int time_diff = 0;
  motor_throttle = MOTOR_FULL_SPEED / APPROACH_WALL_SPEED_MODIFIER;
  do {
    TextOut(0, 48, StrCat("Distance", NumToStr(distance_start), "         "));
    TextOut(0, 40, StrCat("Distance", NumToStr(distance_now), "         "));
    TextOut(0, 32, StrCat("time", NumToStr(time_diff), "         "));
    Wait(APPROACH_WALL_MEASURE_INTERVAL);
    time_diff += APPROACH_WALL_MEASURE_INTERVAL;
    distance_now = SensorUS(SENSOR_ULTRASONIC);
  } while(distance_now > DISTANCE_CORNER_MIDDLE + DISTANCE_WALL_BUFFER);
  approx_speed = (APPROACH_WALL_SPEED_MODIFIER * ((distance_start - distance_now) / time_diff));
  TextOut(0, 0, StrCat("speed", NumToStr(approx_speed), "      "));
}

inline int initialize() {
  // initialize sensors
  SetSensorLight(SENSOR_LEFT);
  SetSensorLight(SENSOR_RIGHT);
  SetSensorLight(SENSOR_LINE);
  SetSensorUltrasonic(SENSOR_ULTRASONIC);

  // calculate difference between floor and line
  int test = Sensor(SENSOR_LEFT);
  unsigned int light_average = (Sensor(SENSOR_LEFT) + Sensor(SENSOR_RIGHT)) / 2;
  light_threshold = 0.5 * (light_average - Sensor(SENSOR_LINE));
  //start(measureGap());
  StartTask(approachWall);
  return STATE_FOLLOW_LINE;
}

inline int follow_line() {
  unsigned int value_left = Sensor(SENSOR_LEFT);
  unsigned int value_right = Sensor(SENSOR_RIGHT);
  unsigned int value_line = Sensor(SENSOR_LINE);
  unsigned int difference_left = value_left - value_line;
  unsigned int difference_right = value_right - value_line;

  TextOut(0, 24, StrCat("l=", NumToStr(value_left), "-", NumToStr(value_line), "=", NumToStr(difference_left), "       "));
  TextOut(0, 16, StrCat("r=", NumToStr(value_right), "-", NumToStr(value_line), "=", NumToStr(difference_right), "       "));
  TextOut(0, 8, StrCat("t=", NumToStr(light_threshold)));

  if (difference_left > light_threshold && difference_right > light_threshold) {
    gap_traversed = 0;
    TextOut(0, 0, "move forward!");
    TextOut(0, 0, "move forward!");
    // NOTE: move forward
    OnRev(MOTOR_BOTH, motor_throttle);
    return STATE_FOLLOW_LINE;
  } else if (difference_left <= light_threshold && difference_right > light_threshold) {
    gap_traversed = 0;
    TextOut(0, 0, "move left!   ");
    // NOTE: move left
    OnRev(MOTOR_RIGHT, motor_throttle);
    OnRev(MOTOR_LEFT, motor_throttle - MOTOR_CURVE_DRAW);
    return STATE_FOLLOW_LINE;
  } else if (difference_left > light_threshold && difference_right <= light_threshold) {
    gap_traversed = 0;
    TextOut(0, 0, "move right!    ");
    // NOTE: move right
    OnRev(MOTOR_LEFT, motor_throttle);
    OnRev(MOTOR_RIGHT, motor_throttle - MOTOR_CURVE_DRAW);
    return STATE_FOLLOW_LINE;
  } else {
    TextOut(0, 0, "gap!        ");
    OnRev(MOTOR_BOTH, motor_throttle);
    // TODO: move forward and count gap
    
    if(gap_min_diff == -1) {
      if(motor_throttle == MOTOR_FULL_SPEED) {
        return STATE_FOLLOW_LINE;
      } else {
        if(approx_speed != -1) {
          gap_min_diff = 6 / approx_speed;
          return STATE_TURN_AROUND;
        }
        return STATE_FOLLOW_LINE;
      }
    } else {
      if(gap_traversed > gap_min_diff) {
        // TODO: jump to next task
        return STATE_FOLLOW_LINE;
      } else {
        Wait(MS_50);
        gap_traversed += MS_50;
        return STATE_FOLLOW_LINE;
      }
    }
    
    return STATE_FOLLOW_LINE;
  }
  return -1;
}


task main() {
  while (1) {
    switch (state) {
    case STATE_INITIALIZE:
      state = initialize();
      break;
    case STATE_FOLLOW_LINE:
      state = follow_line();
      break;
    }
  }
}
